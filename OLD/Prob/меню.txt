Как создать внутриигровое меню в Unity
9 мин
218K
Unity
*
Графический дизайн
*
Дизайн игр
*
Разработка игр
*
Android
*
Туториал
Из песочницы
Как создать внутриигровое меню в Unity

Unity позволяет не делать меню настроек, так как есть встроенный диалог настроек качества и разрешения перед запуском игры. Однако если вы хотите сделать вашу игру неповторимой и показать, на что способны, как дизайнер, то эта статья именно для вас. После прохождения этого туториала вы сможете создавать свое собственное меню с таким функционалом – настройки громкости, разрешения, качества изображения, переключения полноэкранного и оконного режима. Интересно? Тогда запускай Unity и поехали!

Создание и дизайн главного меню и меню настроек

1. Создаем две сцены: Menu и Game
2. Открываем File->BuildSettings и перетаскиваем созданные сцены в Scenes in build.

image

Теперь можем приступать к созданию пользовательского интерфейса. Откройте сцену Menu и добавьте Panel. Сразу добавляется Canvas(Холст) и дочерним объектом к нему добавляется Panel (Панель).

image

Обратим внимание на инспектор для Canvas. А именно на компонент Canvas.

image

Render Mode автоматически выставлен на Screen Space – Overlay.

Немного информации:

Screen Space – Overlay:
Способ рендеринга, при котором Canvas напрямую привязан к экрану. Если изменить разрешение экрана или размер, то Canvas с такой настройкой тоже изменит свой масштаб на подходящий. UI в таком случае будет отрисовываться поверх других объектов.

Важен порядок размещения объектов в иерархии. Холст Screen Space – Overlay должен находиться в самом верху иерархии, иначе он может пропасть из виду.


Screen Space – Camera:
В таком случае, Холст прикрепляется в камере. Для такой настройки обязательно нужно указать камеру которой соответствует Холст. Как и в предыдущем пункте, Холст будет менять свой масштаб в зависимости от разрешения и размера экрана, а также от области видимости камеры.

Так же для Холста с такими настройками важно размещение относительно других объектов. На переднем плане будут объекты, которые находятся ближе к камере, не зависимо от того, это UI или другие GameObjects.


World Space:
Холст размещается, как любой другой объект без привязки к камере или экрану, он может быть ориентирован как вам угодно, размер Холста задается с помощью RectTransform, но то, как его будет видно во время игры, будет зависеть от положения камеры.
В данном задании мы будем использовать Screen Space – Overlay.
Давайте настроим цвет панели. Можно также добавить картинку на фон. Для этого нужно обратить внимание на компонент Image в Инспекторе панели.



image

Как видите, картинка добавляется в поле Source Image. Картинку можно просто перетащить из файлов проекта, либо кликнуть на кружочек справа от поля.

Цвет выбирается в поле Color, либо с помощью инструмента пипетки.
Важно знать, что пипетка позволяет выбрать цвет за пределами Unity.
После того, как выбрали цвет или картинку, нам нужно разместить кнопки, которые всем будут управлять, а так же текст. Чтобы упростить себе задачу, для Panel мы добавим еще один компонент, который называется Vertical Layout Group. И сразу настроим его.

Нам необходимо разместить все кнопки и текст по центру экрана. Для этого находим в компоненте Vertical Layout Group пункт Child Alignment и выбираем Middle Center. Теперь все наши элементы, будь то кнопки или текст, будут выравниваться по центру, независимо от разрешения экрана.

Так же убираем галочки с ChildForceExpand. Должно получиться так:

image

Данный компонент можно настраивать в зависимости от того, какой вид вы хотите получить.

В нашем меню должны быть следующие кнопки:

1. Start Game
2. Settings
3. Exit

Сейчас, добавляем Text дочерним элементом нашей Панели. Можете заметить, как он прикрепляется по центру. Иногда для этого требуется созданный элемент в окне Scene просто передвинуть на Panel и тогда он выровняется. Настраиваем текст так, как хочется с помощью компонента Text(Script) в инспекторе.

image

После добавляем Button. Кнопка добавится под текст.

Разберем компонент Button нашей кнопки. Нас интересует Transition – то, как кнопка будет реагировать на действия мышки. В Unity реализовано несколько способов. Пока рассмотрим довольно простой Color Tint. Это значит, что кнопка будет менять свой цвет при определенных состояниях. Интерфейс для настройки довольно удобный. Настраиваем так, как нравится.

image

Так же у объекта Button есть дочерний объект Text – это текст который будет отображаться на кнопке. В тексте прописываем Play.

Кажется, Текст и Кнопки находятся слишком близко друг к другу.

Что бы это исправить для нашего Текста Menu добавляем еще один компонент, который называется Layout Element. И ставим галочку напротив Ignore Layout.

image

После этого выставляем Anchor на Middle-Center.

image

Потом добавляем еще три кнопки и называем их Settings, Credits, Exit.
Можно поменять размеры кнопок. На этом этапе меню выглядит так:

image

Переходы между main menu и settings

Что бы переходить на меню опций не обязательно делать новую сцену.
Для начала создаем пустой GameObject (Create Empty) как Child нашего Холста. Назовем его Main menu. Потом нашу панель, со всеми инструментами сделаем дочерними элементами этого объекта. Должно получиться так:

image

Выбираем наш MainMenu объект и сделаем его дубликат. С выбранным элементом нажимаем комбинацию клавиш Ctrl+D. У нас появится новый объект.

image

Переименовываем новый объект в Settings. Для удобства управления инактивируем MainMenu.

image

Дальше в панели Settings переписываем текст на Settings, а так же удаляем все кнопки.
В настройках мы сделаем следующее – Fullscreeen, настройки громкости, качество изображения, разрешение экрана.

За контроль Fullscreen будет отвечать элемент Toggle.
За громкость – Slider.
За качество изображения и разрешение – Dropdown.

Между каждыми элементами следует разместить текст, который будет обозначать название каждой настройки. Следует также добавить кнопку, которая будет возвращать нас обратно в главное меню.

Можно настроить Spacing в Vertical layout group, чтобы между элементами было немного пространства. Добавим на панель картинку и в итоге получим такой результат:

image

Программирование кнопок

Перейдем к написанию скрипта меню.

Нам нужно, чтобы по нажатию кнопки Play у нас запускалась другая сцена с нашей игрой, а по нажатию кнопки Exit игра закрывалась.

Это мы и пропишем в нашем скрипте.

Для MainMenu добавляем новый компонент MenuControls.cs и отрываем его.

Первое что надо сделать – удалить существующие методы Start() и Update() – тут они нам не нужны.

Дальше нам надо подключить следующее:

using UnityEngine.SceneManagement;
Объяснить с

После этого напишем свой метод для нажатия кнопки Play. Метод должен быть public — нам нужно иметь возможность видеть его за пределами нашего скрипта.

За загрузку сцены отвечает SceneManager и у него есть метод LoadScene. Существует несколько перегрузок метода. Можно передавать имя сцены, которую вы хотите загрузить. В нашем случае это сцена «Game».

В итоге функция будет выглядеть следующим образом.

public void PlayPressed()
    {
        SceneManager.LoadScene("Game");
    }
Объяснить с

Так же создаем метод для выхода из игры:

    public void ExitPressed()
    {
        Application.Quit();
    }
Объяснить с

Однако в Unity мы не увидим результата работы этого метода, так как подобное работает только в билде. Для того что бы проверить, что все работает правильно, добавляем в метод строчку

Debug.Log("Exit pressed!");
Объяснить с

Теперь необходимо прикрепить события кнопок к этим методам. Выбираем кнопку Play и находим в инспекторе следующее:

image

Это событие кнопки, которое по нажатию будет вызывать подписанные на событие методы. Добавляем метод нажимая на +.

В появившееся окно нужно перетащить объект, в котором содержится нужный скрипт. В нашем случае это Main Menu.

После этого нужно выбрать скрипт MenuControls и найти метод PlayPressed().

image

Точно также делаем для кнопки Exit. Только теперь выбираем метод ExitPressed().
Для кнопки Settings нам не нужно писать никакой код, так как некоторый функционал уже встроен.

Суть в том, что мы будем активировать GameObject. На этом этапе у вас должен быть активным MainMenu, а Settings не должно быть видно. Так же видим, что когда мы активируем Settings, он полностью перекрывает Menu. Суть в том, что играет роль порядок расположения дочерних объектов Холста – в каком порядке они расположены в иерархии в том порядке они и будут прорисовываться. Поскольку Settings у нас находятся над Main Menu, то они перекрывают меню.
Это мы и будем использовать.

Выбираем кнопку Settings и в OnClick() перетаскиваем наш объект Settings. В функциях выбираем GameObject ->SetActive(); и ставим галочку. Вот так:

image

Ну а для кнопки Back, которая находится в меню опций, можно таким же образом подключить событие SetActive для объекта Settings, но на этот раз нам нужно инактивировать наш объект, поэтому мы просто не ставим галочку.

Вот и все, мы закончили создание меню, а в следующей части продолжим и сделаем так, чтобы игра реагировала на изменения настроек.

Настройки

Настройки полного экрана

Первое что мы пропишем это переключение полноэкранного и оконного режимов.
Нужно убрать галочку с пункта Is On нашего Toggle элемента.
Создаем скрипт для объекта Settings. Назовем его Settings.cs.

Для начала нам надо хранить переменную типа bool которая будет отображать текущее состояние – полноэкранный режим или нет. А потом, по изменению toggle эта переменная будет переключаться на противоположное значение.

У экрана есть свойство Screen.fullScreen типа bool. Можно просто будем присваивать значение нашей переменной isFullScreen этому свойству.

Код выглядит так:

public void FullScreenToggle()
    {
        isFullScreen = !isFullScreen;
        Screen.fullScreen = isFullScreen;
    }
Объяснить с

Увидеть результат можно только в билде. Давайте сейчас это сделаем. Учтите, что для того что бы билд был правильным нужно оставить активным только объект MainMenu, а Settings отключить. Если это сделано, то запускаем билд через File->BuildSettings и нажимаем кнопку Build.

После этого можно проверить работу программы. Если все правильно, то по нажатию галочки сразу будет изменяться режим.

Изменения громкости звука в игре

Для работы с настройками звука нам для начала понадобится AudioMixer, а также какой-нибудь трек, на котором мы будем проверять работу наших настроек.

Добавим эти два элемента. Сначала добавляем AudioMixer. Правой кнопкой мыши в окне Project ->Create->AudioMixer.

Называем его GameSettings. После этого открываем окно AudioMixer: Window->Audio Mixer (Ctrl + 8).

Что бы контролировать параметры миксера через скрипт, их нужно сделать видимыми для этого скрипта. Эта процедура называется ExposeParameters. Для этого кликаем на Mixer и в инспекторе находим volume и кликаем правой кнопкой мыши. Выбираем Expose to script:

image

Теперь в окне Audio Mixer обратите внимание на пункт Exposed Parameters в верхней левой части.

image

Теперь там есть параметр. Кликаем на него и называем наш параметр masterVolume. Следует запомнить имя, которое ему присваиваем – его нужно будет указать в коде.

Переходим в Settings.cs и создаем поле AudioMixer, чтобы получить ссылку на него в коде.

public AudioMixer am;
Объяснить с

потом создаем метод

public void AudioVolume(float sliderValue)
    {
        am.SetFloat("masterVolume", sliderValue);
    }
Объяснить с

Метод SetFloat будет принимать значения нашего слайдера и присваивать это значение параметру “masterVolume”.

Осталось прикрепить наш метод к событиям слайдера. Находим в инспекторе слайдера поле On Value Changed и точно так же прикрепляем объект. Вот только теперь нам надо не просто выбирать метод из списка, а использовать поле Dynamic float. Как видите, там уже есть наш метод, и он будет получать переменную от самого слайдера. Также нужно не забыть перетащить AudioMixer в соответствующее поле в компоненте Settings.cs.

image

Обратите внимание, что мы напрямую привязываем значение слайдера к значениям аудио-миксера. В аудио миксере громкость изменяется от -80 до 20. Нам же достаточно менять от -80(нет звука) до 0(нормальный звук). В настройках слайдера минимальное значение выставляем на -80, максимальное на 0.

image

Теперь добавим звуки в нашу игру, чтобы проверить работу скрипта.
На canvas добавим компонент Audio Source.
Настроим его следующим образом:

image

Audio Clip – саундтрек
Output – Мастер нашего миксера (дочерний объект)
Loop – поставить галочку – зациклить композицию, чтобы она играла постоянно.

Качество изображения

В Unity уже встроены настройки качества изображения. Edit->Project Settings->Quality. В инспекторе видим Quality settings. Их можно добавлять и настраивать.

Особенностью работы с настройками качества является следующее:
Каждой настройке соответствует индекс, который мы можем получить из Dropdown. Все что нужно сделать – переписать соответствующие пункты в нужные индексы в нашем UI элементе. Открываем его и в инспекторе находим Dropdown(Script) и в нем пункт Options. Дальше вписываем настройки в нужном порядке. У меня получилось так:

image

Дальше нужно прописать код. Мы продолжаем дополнять методами наш скрипт Settings.cs
Создаем метод, который будет принимать int – индекс выбранного пункта.

public void Quality(int q)
    {
        QualitySettings.SetQualityLevel(q);
    }
Объяснить с

Сохраняем скрипт и подключаем метод к событию на нашем меню. На этот раз это событие Dropdown – On Value Changed.

Поскольку наш метод будет получать значение от самого UI элемента, то мы выбираем название метода из группы Dymanic int. по аналогии с предыдущим пунктом.

Разрешение экрана

Экраны у всех разные и наперед угадать какие разрешения на них будут поддерживаться невозможно. Поэтому для настроек разрешения экрана нужно сначала получить все возможные разрешения, а потом заполнить список разрешений этими значениями.

Первое что нам понадобится – массив типа Resolution[] где мы будем хранить значения разрешений экрана.

Однако для пунктов выпадающего списка тип – string. Поэтому создаем список List<> в который мы будем сохранять значения возможных разрешений. Для работы со списками необходимо подключить:

using System.Collections.Generic;
Объяснить с

Также нам понадобится ссылка на соответствующий Dropdown. Для работы с UI элементами следует также прописать:

using UnityEngine.UI;
Объяснить с

В скрипте получим следующие поля:

Resolution[] rsl;
List<string> resolutions;
public Dropdown dropdown;
Объяснить с

Инициализацию и заполнение проводим в методе Awake. Этот метод вызывается при запуске объекта, соответственно выполняется раньше, чем все остальные методы.

Получаем значения и каждое из них добавляем в List в формате ширина*высота. После этого очищаем список Dropdown и заполняем его новыми опциями.

public void Awake()
    {
        resolutions = new List<string>();
        rsl = Screen.resolutions;
        foreach (var i in rsl)
        {
            resolutions.Add(i.width +"x" + i.height);
        }
        dropdown.ClearOptions();
        dropdown.AddOptions(resolutions);
    }
Объяснить с

Теперь нужно создать метод, который будет менять разрешение экрана. Как и в предыдущих пунктах – принимать значение будем от UI элемента. Создаем функцию, которая принимает int

public void Resolution(int r)
    {
        Screen.SetResolution(rsl[r].width, rsl[r].height, isFullScreen);
    }
Объяснить с

В SetResolution необходимо передать параметры – ширина, высота и булевскую переменную, отвечающую за полный экран. У нас такая уже есть – это isFullScreen. Передаем ее в функцию.
Дальше не забываем подключить к соответствующему событию наш метод Resolution из группы Dynamic Int, а так же добавить ссылку на нужный Dropdown.

image

Готово. Теперь можно использовать это меню вместо скучного дефолтного лаунчера. Однако, чтобы был толк нужно отключить его запуск.

Edit->ProjectSettings-> Display Resolution Dialog-Disabled

image

Теперь у вас есть возможность создавать свои менюшки и использовать в них любые дизайнерские решения, которые сделают игру уникальной и запоминающейся.

How to Create a Start Menu in Unity
November 3, 2023 by Daniel Buckley


You can access the full course here: CREATE YOUR FIRST 3D GAME IN UNITY

Welcome to this beginner-friendly tutorial where we will guide you through setting up a basic Unity menu for your game. Your game’s main menu is not only the first impression players have of your game, but it also plays a vital role in navigation. In this tutorial, we will walk you through creating a simple but professional-looking Unity menu, including various buttons like ‘Play’ and ‘Quit’ in a game scene.

So without further ado, let’s get started!

Table of contents
Prerequisites
Unity Menu – Part 1
The Unity Menu Scene
The Title Text
The Unity Menu Buttons
The Unity Menu Script
Updating The Scene
The Quit Button Challenge
Unity Menu – Part 2
The Quit Button Challenge Implementation
Unity Menu Wrap-Up
Transcript – Unity Menu – Part 1
Transcript – Unity Menu – Part 2
Prerequisites
The tutorial assumes you have some familiarity with C# programming and using Unity Editor.

If you need help, the Unity Game Development Mini-Degree offers an extensive collection of courses from the basics to game mechanics, procedural maps and even optimizing Unity menu. This Mini-Degree has been recognized as an invaluable resource for not just game development, but an array of non-game industries, perfecting Unity skills and opening doors to unlimited opportunities.

CTA Small Image - How to Create a Start Menu in Unity
FREE COURSES AT ZENVA
LEARN GAME DEVELOPMENT, PYTHON AND MORE
ACCESS FOR FREE
AVAILABLE FOR A LIMITED TIME ONLY
Unity Menu – Part 1
In this lesson, we’ll set up the Unity Menu for our game.

The Unity Menu Scene
This Unity Menu will be a separate scene. Let’s create a new scene called Menu in the Scenes folder now.

Scenes folder

Then, we’ll double-click on the Menu asset to open the Menu scene. You’ll see a default empty scene in your Editor.

Menu scene

First, we’ll change the background we have:

Select the Main Camera object
Go to the Camera component in the Inspector window
Set the Clear Flags property to the Solid Color option. This way, the camera will render color as a background
Set the Background property to a nice green color. This will be the background color of the scene
scene background

Now you should have the green background in the Game view.

Game view

Then, we’ll create a new Canvas object in the Hierarchy, as we did earlier.

Canvas object

The Title Text
Now, let’s create a title text for our game:

Create a new TextMeshPro object as a child of the Canvas
Name it TitleText
Position it above the center of the Canvas
Title Text

Canvas

Then, we’ll configure the TitleText > TextMeshPro component in the Inspector window the following way:

Set the Text to “My 3D Game“
Enable the Bold Font Style
Make the Font Size bigger. We’ll go with 60
Set the Alignment to Center-Middle
TextMeshPro component

Here’s how your title should look like in the Game view:

Game view

The Unity Menu Buttons
Next, we’ll create a button that will start the game:

Right-click in the Hierarchy and select the UI > Button – TextMeshPro option from the context menu
Name that button PlayButton
Make the PlayButton about the same size as the TitleText
Position the PlayButton in the middle of the Canvas
PlayButton

PlayButton in Canvas

Then, let’s select the child Text object of the PlayButton, go to the Inspector, and set the TextMeshPro > Text to “Play“.

TextMeshPro Inspector

Game View

Next, we’ll create a button to quit our game:

Duplicate the PlayButton by selecting it and pressing the Ctrl+D hotkey
Rename the duplicate to QuitButton
Move QuitButton to be below the PlayButton
Change the text on the QuitButton to “Quit“
Quit Button as seen in the Unity Hierarchy

Menu screen with Play and Quiz buttons present

You can start this scene and click on the buttons, but nothing will happen right now, as we have to set those buttons up.

The Unity Menu Script
Let’s create a script to control those buttons:

Create a new C# script called Menu in the Scripts folder
Attach this Menu script to the Canvas object
Menu Script

Then, we’ll open the Menu script and do the following:

Remove the Start and Update functions, as we won’t need them
Add the SceneManagement library so we could load the scenes from this script
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement; // Add me!!
public class Menu : MonoBehaviour
{
}
Our UI buttons can call functions from the scripts. So, we’ll create the functions that those buttons will call. Let’s start with a function for the Play button:

Create a new public function called OnPlayButton
In that function, make the Scene Manager load a scene with an index of 1. This will be our Level 1 
public void OnPlayButton ()
{
    SceneManager.LoadScene(1);
}
Next, we’ll create a function for the Quit button:

Create a new public function called OnQuitButton
In that function, call the Application.Quit function to make the game close
public void OnQuitButton ()
{
    Application.Quit();
}
Here’s what the full Menu script looks like:

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
public class Menu : MonoBehaviour
{
    // Called when we click the "Play" button.
    public void OnPlayButton ()
    {
        SceneManager.LoadScene(1);
    }
    // Called when we click the "Quit" button.
    public void OnQuitButton ()
    {
        Application.Quit();
    }
}
Updating The Scene
Now, let’s get back to the Unity Menu scene in Unity Editor. We have to connect our buttons to the Menu script now.

We’ll set up the PlayButton first:

Select the PlayButton and go to the Inspector
There is a menu for the On Click event at the bottom of the Button component
Click on a plus icon there to add a new entry
Drag the Canvas object to the object field of that entry
Select the Menu > OnPlayButton function in the function field
Now, when you click on the Play button, this button will call the Menu.OnPlayButton function.

Menu.OnPlayButton function

Before testing this Play button, we have to add the Menu scene to the Build Settings:

Press the Ctrl+Shift+B hotkey to open the Build Settings window
Press the Add Open Scenes button to add the Menu scene to the list
Drag the Menu scene to the top of this list
Build Settings

If you start the game and click the Play button now, it will take you to the Level 1.

Play button

Level 1

The Quit Button Challenge
As a bit of a challenge, we want you to connect the Quit button to the Menu script by yourself.

In this lesson, we created the Unity Menu and made it start the first level. In the next section, we’ll finish our work on the Menu.

Unity Menu – Part 2
In this lesson, we’ll connect the Quit button to the Menu script.

The Quit Button Challenge Implementation
Here’s what you need to do to connect the Quit button to the Menu class:

Select the QuitButton game object
Go to the Button component in the Inspector
Add a new entry to the On Click event listener
Drag the Canvas object to the object field of that entry
Select the Menu > OnQuitButton as a function of that entry
Inspector with the QuitButton function in On Click

If you start the game and try to press the Quit button, nothing will actually happen. That’s because the Application > Quit function works only in the built project, and doesn’t work in Editor.


Unity. Создание кнопок с помощью скрипта
Вопрос задан 6 лет 11 месяцев назад
Изменён 6 лет 11 месяцев назад
Просмотрен 3k раз
0

Работаю с движком Unity, на языке c#. Я не знаю как сделать так, что бы кнопки созданные с помощью скрипта выполняли какой то метод, а именно присваивание определенного значению моему иксу и удаляли сами себя после присваивания. Мне нужно будет создать таких кнопок около 100, и они должны нести в себе случайное число, как на гифке( в верхней части гиф кнопки созданы без использования скрипта и работают как нужно, за исключением удаления самой себя, а в нижней части кнопки создаются скриптом, но не работают) Подкиньте статью на эту тему или может даже решение проблемы, если вам не трудно

визуализация проблемы.

Код:

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using System;


public class NewBehaviourScript : MonoBehaviour
{

    public Transform panel;
    string Number;
    public Font font;
    public Text x;
    int chislo = 0;

    private void FixedUpdate()
    {
        x.text = string.Format("X= {0}", chislo);
    }

    public void createButton()
    {

        Number = Convert.ToString(UnityEngine.Random.Range(1, 50));

        GameObject newButton = new GameObject("knopka" + Number, typeof(Image), typeof(Button), typeof(LayoutElement));
        newButton.transform.SetParent(panel);

        newButton.GetComponent<Image>().color = new Color(0, 1, 0, 1);
        newButton.transform.SetParent(newButton.transform);
        RectTransform rect = newButton.GetComponent<RectTransform>();
        rect.anchorMin = new Vector2(0, 1);
        rect.anchorMax = new Vector2(0, 1);
        rect.anchoredPosition = new Vector2(70, -65);
        rect.sizeDelta = new Vector2(100, 100);



        GameObject newText = new GameObject("New text" + Number, typeof(Text));
        newText.transform.SetParent(newButton.transform);
        newText.GetComponent<Text>().text = Number;
        newText.GetComponent<Text>().font = font;
        newText.GetComponent<Text>().fontSize = 50;
        RectTransform rt = newText.GetComponent<RectTransform>();
        rt.anchorMin = new Vector2(0, 0);
        rt.anchorMax = new Vector2(1, 1);
        rt.anchoredPosition = new Vector2(0, 0);
        rt.sizeDelta = new Vector2(0, 0);
        newText.GetComponent<Text>().color = new Color(0, 0, 0);
        newText.GetComponent<Text>().alignment = TextAnchor.MiddleCenter;
    }

    public void chislo1()
    {
        chislo = 1;
    }
    public void chislo6()
    {
        chislo = 6;
    }
    public void chislo11()
    {
        chislo = 11;
    }
    public void chislo43()
    {
        chislo = 43;
    }
    public void chislo22()
    {
        chislo = 22;
    }
    public void chislo85()
    {
        chislo = 85;
    }


}

-----------------------------------------------

Unity UI. Создаём меню. Часть первая
От astler / 3 минут чтения / 17 июня, 2021 / unity
Привет. Мы узнали, что такое кнопки, изображения, текст. Пробовали их разные параметры. Этих знаний уже достаточно, чтобы сделать что-то своё. Предлагаю в этот раз не только затронуть новый UI элемент Unity — Panel, но и создать своё меню для потенциальной игры. Бета-версию меню =)

Упомянутый Panel по сути дела является обычным Image, но так как он вынесен отдельно, то стоит попробовать и его. Чаще всего этот элемент можно увидеть в виде фона для других фрагментов UI. А никаких взаимодействий пользователя с ним не предусмотрено.

Создаём своё меню
Для начала определимся с фоном. Стандартный фон в 2D проекте – не самый приятный цвет заливки:


Его можно отрегулировать в камере:


Я большой фанат живых бекграундов. Т.е. чтобы на фоне загружался какой-то уровень и что-то происходило. Но пока для такого рановато.

Так что сделаем что-то максимально минималистичное. Я предлагаю выбрать… Белый!

Определимся и с тем, что вообще будет на экране. Я хочу добавить 4 кнопки (Play, Continue, Settings и Exit), заголовок (Text) и для кнопок и заголовка будет две фоновые панели.

В соответствии с этим гайдом: Unity UI. Более продвинутые Button добавляю несколько круглых кнопок с иконками в пустого родителя. Родителю добавлю компонент Vertical Layout Group:


Выравнивание дочерних объектов ставим в центре. Кнопкам прописываем текст: Play, Continue, Settings, Exit. Шрифт для них это бесплатный Montserrat-Bold, а иконки взяты из бесплатного пака 64 Flat Game Icons.

Понятное дело, нужно подкрутить размеры текста, кнопок, иконок. Но это простые и достаточно субъективные моменты, так что не будем на этом останавливаться. Если читали статью про их создание, то проблем возникнуть не должно. И кстати, анимация на кнопках тоже будет взята из того же урока.

Не забывайте и указать Scale для Canvas, чтобы он не сильно искажался на разных устройствах!

Если всё сделано верно, то уже получаем такую вот симпатичную картинку:


Можно пойти более брутальным путём и использовать вместо круглых кнопок – прямоугольные:


Для этого просто убираем круглый спрайт с Image компонента в Button. В некоторых случаях такой вариант больше подойдёт, но сейчас оставлю с закруглением.

Привет, Panel!
Теперь кнопкам нужен фон. Для этого добавляем в канвас элемент Panel:


За внешний вид Panel отвечает компонент Image. Пожалуй, сделаю его прозрачнее, а цвет укажу соответствующий кнопкам. И, конечно же, круглые углы:


Само меню с кнопками вкладываю в панель, подгоняю размеры:



Добавляем заголовок
Помните компонент, который сделал списком наши кнопки? Vertical Layout Group. Предлагаю добавить новый родительский элемент с этим компонентом:


Туда добавить новую Panel, которая будет фоном для заголовка, и переместить уже готовую с кнопками:


Ширину в данном случае будет определять самый первый Main родитель, а панели уже будут подогнаны под него. При этом у нас есть отступ между заголовком и кнопками, а сами элементы будут в центре.

Для заголовка я выбрал шрифт JosefinSans-Regular и указал красноватый цвет.


И ещё раз
Разберём ещё раз всё. Пошагово.

Main компонент, который содержит все остальные, я указал отступы сверху и снизу, т.к. сам элемент растянут по высоте, и указал фиксированную ширину.


Дочерние элементы (две панели) будут расположены вертикальным списком. По высоте их растягивать не будет, что позволит свободно указать её самостоятельно каждому, сохранив расположение элементов в центре. Spacing и есть тот самый отступ между панельками.

Именно поэтому в панелях у нас заблокированы все значения размещения, кроме высоты:


Изображение circle это круг, он скругляет углы, а цвет с alpha каналом позволит увидеть контент за панелью (который мы добавим во второй части), и, конечно, выделяет кнопки и заголовок.


Родитель кнопок тоже содержит элемент Vertical Layout Group, он отвечает за вертикальное расположение кнопок меню.
-----------------------------------------------------------------
Unity UI. Более продвинутые Button
От astler / 3 минут чтения / 13 июня, 2021 / GameDev, unity
Привет. Недавно (тут) мы разбирали Button, т.е. кнопки. Были основные моменты настройки и даже был пример с простой анимацией. Теперь же предлагаю сделать акцент на их внешнем виде. Материал пишу на базе этого видео.

Материальный Button
Много лет, работая на Android, я жил материальным дизайном. Возможно, из-за этого дефолтная кнопка в Unity мне совсем не по душе. А может она просто не очень. Особенно напрягают моменты, когда видишь её без изменений в какой-то инди игре. Пример:


Игра не моя. Досталась бесплатно в Steam, но вообще за неё и денег просят
Кстати, игра не такая плохая. Могла бы быть. Это что-то вроде симулятора экономического. Просто им бы графику починить, да идеи доразвить. Ссылка на игру.

Ладно. Фишка в том, что, чтобы сделать простую кнопку с заливкой – нам вообще не нужны никакие спрайты.

Добавим две кнопки у одной изменим спрайт на None.


Выберем какой-то цвет заливки и поправим цвет текста для большего соответствия. Можно докинуть ещё тень, и получаем такой вот результат:


Как по мне – лучше. Ещё размер текста, шрифт сменить нужно, но даже сейчас выглядит неплохо. При этом без каких-либо спрайтов.

Button с Image и Text
Кнопка с текстом — это хорошо, но иногда нам нужны кнопки, где будет не только текст, но и какая-то иконка. Сделать это не сложно. Копируем оранжевую Button ниже и добавляем в неё Image.


В качестве иконки я взял спрайт из этого пака.


В Button добавляем новый компонент Horizontal Layout Group:


Ставим флажки вот так. Это значит, что он не будет растягивать дочерние элементы на всю ширину родителя, но при этом будет всё ещё контролировать их размер. Child Alignment определяет расположение дочерних элементов. Я указал центр.


Смотрим что вышло. Как вы поняли, этот компонент расположил дочерние элементы горизонтально:


Выглядит не особо, так что переходим в Image, и туда добавляем компонент Layout Element. Тут укажем предпочитаемый размер дочернего элемента:


И да, Image надо бы поставить раньше текста.


Теперь вернемся к Horizontal Layout Group и укажем Spacing. Эта величина отвечает за отступ между элементами.


И добавим ещё один очень полезный компонент. Он будет подгонять размер кнопки под ширину содержимого.

Называется он Content Size Fitter. Указываем для горизонтальной величины:


И получаем соответствующую контенту кнопку:


Теперь в Horizontal Layout Group добавим отступы (Padding) и будет выглядеть просто шикарно!


Главный прикол компонента Content Size Fitter в том, что если мы добавим текст побольше, то кнопка станет больше вместе с ним:


Это нужно не всегда, но знать о таком компоненте стоит.

Rounded Button
Кнопка с кругленькими углами достаточно частое явление. Сделать её очень просто, но для этого нам нужен круглый спрайт. Буквально круг.


Его Border оставляем чётко в центре. Чтобы не было сильного искажения. Правда от размера этого спрайта многое зависит. Если высота кнопки будет меньше, то её форма будет искажена. Это стоит учитывать.


Больше анимаций!
Теперь добавим стандартные анимации для разных состояний. Для этого создаём ещё один Animator Controller и открываем окошко Animation (Ctrl+6).

Например, добавим анимацию увеличения при наведении курсора. Только в отличие от предыдущего примера, анимация не будет постоянно прыгать, а просто кнопка будет увеличена пока на ней есть курсов.

Для этого сначала укажем нормальное состояние:


Тут указываем стандартные величины, это будет отправная точка для анимации.

Теперь настроим анимацию для состояния при наведении курсора. Тут всё так же, но числа чуть больше.


А для нажатия уменьшим эти же величины:


Для каждого перехода можно отредактировать время, плавность и т.д. Это поможет сделать анимацию визуально более отзывчивой.


Кстати, в анимацию можно включить большую часть изменяемых значений. Например цвет. Нужно добавить нормальный цвет, как и для масштаба. А потом, например, для анимации при нажатии, где он будет темнее.

Чтобы не запутаться в величинах и значениях есть такая классная функция, как захват изменений. Я её так называю -_-


Суть в том, что после нажатия на кнопку записи, в анимацию будут добавлены все изменённые поля. При этом можно по кадрово их изменять и анимировать. Очень удобно.
--------------------------------------
https://learn.unity.com/tutorial/creating-ui-buttons

----------------------------------------------------
Наше главное меню будет состоять из трёх кнопок.


«Начать Игру» - запускает сцену с игрой.
«Настройки» - закрывает область с кнопками, и открывает область с настройками. В открытом окне с настройками будет находиться кнопка «Возврат в главное меню», которая закрывает область настроек и открывает область главного меню.
«Выход» - закрывает игру.
Для начала создадим игровой объект типа UI – Canvas, где и будут располагаться все элементы нашего интерфейса. Далее настраиваем наш Canvas в окне Inspector следующим образом:

В поле Render Mode выбираем Screen Space – Camera. Это нужно, чтобы наш канвас привязать к нашей игровой камере.
В поле Render Camera перетаскиваем объект нашей камеры из окна Hierarchy.
В поле UI Scale Mode выбираем Scale With Screen Size.
В поле Reference Resolution указываем Х=1920 Y=1080. Если Вы создаёте игру для мобильных устройств, то установите Х=1080 Y=1920

Далее создадим ещё 2 игровых объекта типа UI – Image, Первый объект будет служить фоном игрового меню. Назовём его Background. А второй объект будет фоном для области с настройками. Назовём его FonOptions. Поместим их внутрь канваса, и настроим их в окне Inspector.

В поле Source Image перетаскиваем наши фоновые изображения (Background и fonOptions).
Устанавливаем необходимые размеры Width и Height у компонента Rect Transform. Для объекта Background это 1920x1080. А для FonOptions укажите такие значения, которые удобны для Вас.

Далее создадим 4 кнопки: «Начать игру», «Настройки», «Выход», и «Возврат в главное меню». Для этого создаём 4 игровых объекта типа UI – Button. Назовём их BtnStart, BtnOptions, BtnEnd, и BtnReturn. Настраиваем кнопки в поле Inspector следующим образом:

В поле Source Image перетаскиваем изображения наших кнопок из окна Project.(Start, options, exit, return) .
В поле Preserve Aspect поставьте галочку, чтобы изображение стало пропорциональным по сторонам.

Остался последний штрих. Сейчас необходимо сгруппировать две наши области. Первая область будет включать в себя все 3 кнопки. Вторая область будет включать в себя область настроек, вместе с кнопкой возврата в главное меню.

Для создания таких областей создадим 2 новых и пустых игровых объекта. Назовём их Area1 и Area2.

В первый игровой объект перетащим 3 кнопки(BtnStart, BtnOptions, BtnEnd). А во второй игровой объект перетащим одну кнопку(BtnReturn) и фоновую картинку(FonOptions). Объект Area2 временно отключим в окне Inspector, сняв галочку с объекта.


Программная часть
Сейчас мы будем делать так, чтобы все наши кнопки выполняли те функции, для которых они и предназначались. Как Вы помните, всего у нас 4 кнопки, которые сейчас мы и будем реализовывать.

Кнопка «Начать Игру»
Кнопка «Начать Игру» должна запускать сцену с игрой. Для этого создадим C# скрипт с названием, например, StartGame, и пропишем в него следующий код.

using UnityEngine;
using UnityEngine.SceneManagement;

public class StartGame : MonoBehaviour
{
    public void StartGame()
    {
        SceneManager.LoadScene("Game");
    }
}
Код для кнопки «Начать Игру» готов! Обязательно убедитесь, что у вас имеется сцена с названием Game.

Теперь необходимо сделать так, чтобы этот скрипт работал. Для этого выполняем следующие действия:

Добавить в объект нашей кнопки BtnStart данный скрипт.
В поле On Click() Выбираем наш метод StartGame()
Теперь создаём C# скрипт для кнопки «Выход», назовём его ExitGame, и пропишем в него следующий код.

using UnityEngine;
using UnityEngine.SceneManagement;

public class ExitGame : MonoBehaviour
{
    public void ExitGame()
    {
        Application.Quit();
    }
}
Теперь необходимо сделать так, чтобы этот скрипт работал. Для этого выполняем следующие действия:

Добавить в объект нашей кнопки BtnEnd данный скрипт.
В поле On Click() Выбираем наш метод ExitGame()
Кнопка «Настройки» должна закрывать область(объект Area1) с тремя основными кнопками, и открывать область(объект Area2) с настройками. Здесь нам не нужно писать какие-либо скрипты, всё уже написано за нас. Осталось их просто подключить. Для этого выполняем следующие действия:

В окне Hierarchy выбираем объект нашей кнопки настроек BtnOptions
В окне Inspector, в поле On Click() создаём событие, выбрав GameObject – Set Active (bool). Перетаскиваем В данное поле объект Area1. ГАЛОЧКУ НЕ СТАВИМ!
Здесь же, создаём второе событие, только перемещать будем объект Area2. ГАЛОЧКУ СТАВИМ!
Готово, теперь осталось сделать кнопку возврата в главное меню. Для этого делаем с кнопкой BtnReturn всё то же самое, что и в предыдущем примере, только наоборот.

В окне Hierarchy выбираем объект нашей кнопки возврата BtnReturn
В окне Inspector, в поле On Click() создаём событие, выбрав GameObject – Set Active (bool). Перетаскиваем В данное поле объект Area1. ГАЛОЧКУ СТАВИМ!
Здесь же, создаём второе событие, только перемещать будем объект Area2.